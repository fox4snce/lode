{% extends "base.html" %}

{% block title %}Chat - Lode{% endblock %}

{% block content %}
<div class="menu-bar">
    <h1>Lode</h1>
    <div class="menu-items">
        <a href="/main">Main</a>
        <a href="/import">Import</a>
        <a href="/analytics">Analytics</a>
        <a href="/find-tools">Find Tools</a>
        {% if feature_flags.get('vectordb', false) %}
        <a href="/vectordb-search">Vector Search</a>
        {% endif %}
        {% if feature_flags.get('chat', false) %}
        <a href="/chat">Chat</a>
        {% endif %}
        <a href="/export">Export</a>
        <a href="/settings">Settings</a>
        <a href="/help">Help</a>
        <a href="/about">About</a>
    </div>
</div>

<div class="container" style="height: calc(100vh - 60px); display: flex; overflow: hidden;">
    <!-- Left Sidebar: Settings -->
    <div style="width: 280px; min-width: 280px; background: #f8f9fa; border-right: 1px solid #ddd; display: flex; flex-direction: column; overflow-y: auto; padding: 16px;">
        <h2 style="margin: 0 0 16px 0; font-size: 18px; font-weight: 600;">Settings</h2>
        
        <!-- Provider Selection -->
        <div style="margin-bottom: 20px;">
            <label style="display: block; font-size: 12px; font-weight: 500; margin-bottom: 6px; color: #7f8c8d;">
                Provider
            </label>
            <select id="provider-select"
                    style="width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; background: white;"
                    onchange="updateModelPlaceholder()">
                <option value="">Loading providers...</option>
            </select>
        </div>
        
        <!-- Model Input -->
        <div style="margin-bottom: 20px;">
            <label style="display: block; font-size: 12px; font-weight: 500; margin-bottom: 6px; color: #7f8c8d;">
                Model
            </label>
            <input type="text" id="model-input"
                   list="verified-models"
                   placeholder="Select a provider first..."
                   style="width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; background: white; box-sizing: border-box;"
                   disabled>
            <datalist id="verified-models"></datalist>
        </div>

        <!-- Verified Models (Quick Pick) -->
        <div style="margin-bottom: 20px;">
            <label style="display: block; font-size: 12px; font-weight: 500; margin-bottom: 6px; color: #7f8c8d;">
                Verified models (this provider)
            </label>
            <select id="verified-model-select"
                    style="width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; background: white;"
                    onchange="if(this.value){ document.getElementById('model-input').value=this.value; selectedModel=this.value; }">
                <option value="">(none yet)</option>
            </select>
        </div>
        
        <!-- Test Button -->
        <div style="margin-bottom: 20px;">
            <button onclick="testModel()" 
                    id="test-button"
                    style="width: 100%; padding: 10px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.2s;"
                    onmouseover="if(!this.disabled) this.style.background='#229954'"
                    onmouseout="if(!this.disabled) this.style.background='#27ae60'">
                <span id="test-button-text">Test Model</span>
            </button>
            <div id="test-status" style="margin-top: 8px; font-size: 12px; min-height: 16px;"></div>
        </div>
        
        <hr style="border: none; border-top: 1px solid #ddd; margin: 20px 0;">
        
        <!-- Context Window (tokens; up to 100,000) -->
        <div style="margin-bottom: 20px;">
            <label style="display: block; font-size: 12px; font-weight: 500; margin-bottom: 6px; color: #7f8c8d;">
                Context Window (tokens)
            </label>
            <input type="number" id="context-window-input" value="4000" min="1000" max="100000" step="1000"
                   style="width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; background: white; box-sizing: border-box;"
                   onchange="saveChatSettings();"
                   placeholder="e.g. 4000 or 100000">
        </div>
        
        <!-- Min Similarity -->
        <div style="margin-bottom: 20px;">
            <label style="display: block; font-size: 12px; font-weight: 500; margin-bottom: 6px; color: #7f8c8d;">
                Min Similarity: <span id="min-sim-value">0.50</span>
            </label>
            <input type="range" id="min-similarity-slider" min="0" max="1" step="0.05" value="0.5"
                   style="width: 100%;"
                   oninput="document.getElementById('min-sim-value').textContent = parseFloat(this.value).toFixed(2); saveChatSettings();">
        </div>
        
        <!-- Max Context Chunks -->
        <div style="margin-bottom: 20px;">
            <label style="display: block; font-size: 12px; font-weight: 500; margin-bottom: 6px; color: #7f8c8d;">
                Max Context Chunks
            </label>
            <input type="number" id="max-chunks" value="5" min="1" max="10"
                   style="width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; background: white; box-sizing: border-box;"
                   onchange="saveChatSettings();">
        </div>
        
        <hr style="border: none; border-top: 1px solid #ddd; margin: 20px 0;">
        
        <!-- Clear History -->
        <div>
            <button onclick="clearHistory()" 
                    style="width: 100%; padding: 10px; background: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 500;">
                Clear History
            </button>
        </div>
        
        <!-- Debug Toggle -->
        <div style="margin-top: 16px;">
            <label style="font-size: 12px; color: #7f8c8d; cursor: pointer; display: flex; align-items: center; gap: 6px;">
                <input type="checkbox" id="show-debug" onchange="toggleDebug(); saveChatSettings();">
                Show debug info
            </label>
        </div>
    </div>
    
    <!-- Main Chat Area -->
    <div style="flex: 1; display: flex; flex-direction: column; overflow: hidden; background: white;">
        <!-- Chat Messages -->
        <div id="chat-messages" style="flex: 1; min-height: 0; overflow-y: auto; padding: 20px; background: #fafafa;">
            <div class="empty-state" style="text-align: center; padding: 60px 20px; color: #999;">
                <p style="font-size: 16px; margin: 0;">Start a conversation by typing a message below.</p>
            </div>
        </div>
        
        <!-- Input Area -->
        <div style="flex-shrink: 0; padding: 16px; border-top: 1px solid #ddd; background: white;">
            <div style="display: flex; gap: 8px; align-items: flex-end;">
                <textarea id="chat-input" 
                          placeholder="Type your message..."
                          style="flex: 1; padding: 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; font-family: inherit; resize: none; min-height: 60px; max-height: 200px; background: #fafafa;"
                          onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); }"
                          rows="3"></textarea>
                <button onclick="sendMessage()" 
                        id="send-button"
                        style="padding: 12px 24px; background: #3498db; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.2s; white-space: nowrap;"
                        onmouseover="if(!this.disabled) this.style.background='#2980b9'"
                        onmouseout="if(!this.disabled) this.style.background='#3498db'">
                    Send
                </button>
            </div>
            <div id="chat-status" style="margin-top: 8px; font-size: 13px; color: #666; min-height: 18px;"></div>
        </div>
    </div>
</div>

<script>
let chatHistory = [];
let availableProviders = [];
let verifiedModels = []; // [{provider, model}]
let selectedProvider = "";
let selectedModel = "";
let _didRenderInitialHistory = false;

// Load available providers on page load
async function loadProviders() {
    try {
        const response = await fetch('/api/chat/providers');
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to load providers: ${response.status} ${errorText}`);
        }
        const data = await response.json();
        availableProviders = data.providers || [];
        
        // Populate provider selector
        const select = document.getElementById('provider-select');
        if (!select) {
            console.error('Provider select element not found');
            return;
        }
        select.innerHTML = '<option value="">Select a provider...</option>';
        
        for (const provider of availableProviders) {
            const option = document.createElement('option');
            option.value = provider.provider;
            option.textContent = provider.name;
            option.dataset.placeholder = provider.placeholder || '';
            select.appendChild(option);
        }
    } catch (error) {
        console.error('Error loading providers:', error);
        const select = document.getElementById('provider-select');
        if (select) {
            select.innerHTML = `<option value="">Error: ${error.message}</option>`;
        }
        const statusDiv = document.getElementById('chat-status');
        if (statusDiv) {
            statusDiv.textContent = `Error loading providers: ${error.message}`;
            statusDiv.style.color = '#e74c3c';
        }
    }
}

async function loadChatSettings() {
    try {
        const resp = await fetch('/api/chat/settings');
        if (!resp.ok) return;
        const data = await resp.json();
        verifiedModels = data.verified_models || [];
        const settings = (data.settings || {});

        // Load last-used provider/model if present
        if (settings.last_provider) {
            const providerSelect = document.getElementById('provider-select');
            providerSelect.value = settings.last_provider;
            updateModelPlaceholder();
        }
        if (settings.last_model) {
            const modelInput = document.getElementById('model-input');
            modelInput.value = settings.last_model;
            selectedModel = settings.last_model;
        }
        // UI settings (defaults from backend if null)
        const ctx = settings.context_window_size != null ? Number(settings.context_window_size) : 4000;
        const ctxInput = document.getElementById('context-window-input');
        if (ctxInput) ctxInput.value = Math.max(1000, Math.min(100000, ctx));
        const minSim = settings.min_similarity != null ? Number(settings.min_similarity) : 0.5;
        const minSimSlider = document.getElementById('min-similarity-slider');
        const minSimValue = document.getElementById('min-sim-value');
        if (minSimSlider && minSimValue) {
            minSimSlider.value = minSim;
            minSimValue.textContent = parseFloat(minSim).toFixed(2);
        }
        const maxCh = settings.max_context_chunks != null ? Number(settings.max_context_chunks) : 5;
        const maxChunksEl = document.getElementById('max-chunks');
        if (maxChunksEl) maxChunksEl.value = maxCh;
        const showDebugEl = document.getElementById('show-debug');
        if (showDebugEl) showDebugEl.checked = !!settings.show_debug;
        refreshVerifiedModelsDatalist();
        
        // Load conversation history if present.
        // IMPORTANT: Only render it once (initial page load). This function is also called
        // after "Test Model" to refresh verified models; re-rendering history would duplicate
        // messages in the chat window and look like they were "re-sent".
        if (!_didRenderInitialHistory && data.history && Array.isArray(data.history) && data.history.length > 0) {
            chatHistory = data.history;
            const messagesDiv = document.getElementById('chat-messages');
            // Clear any existing UI (including the empty state) before restoring.
            messagesDiv.innerHTML = '';
            for (const msg of chatHistory) {
                addMessage(msg.role, msg.content);
            }
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            _didRenderInitialHistory = true;
        }
    } catch (e) {
        // ignore
    }
}

let saveSettingsTimeout = null;
function saveChatSettings() {
    if (saveSettingsTimeout) clearTimeout(saveSettingsTimeout);
    saveSettingsTimeout = setTimeout(async () => {
        saveSettingsTimeout = null;
        try {
            const ctxInput = document.getElementById('context-window-input');
            const minSimSlider = document.getElementById('min-similarity-slider');
            const maxChunksEl = document.getElementById('max-chunks');
            const showDebugEl = document.getElementById('show-debug');
            const ctxVal = ctxInput ? parseInt(ctxInput.value, 10) : undefined;
            await fetch('/api/chat/save-settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    context_window_size: (ctxVal != null && !isNaN(ctxVal)) ? Math.max(1000, Math.min(100000, ctxVal)) : undefined,
                    min_similarity: minSimSlider ? parseFloat(minSimSlider.value) : undefined,
                    max_context_chunks: maxChunksEl ? parseInt(maxChunksEl.value) : undefined,
                    show_debug: showDebugEl ? showDebugEl.checked : undefined
                })
            });
        } catch (e) {
            console.warn('Failed to save chat settings:', e);
        }
    }, 400);
}

async function saveChatHistory() {
    try {
        await fetch('/api/chat/save-history', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({history: chatHistory})
        });
    } catch (e) {
        // Silently fail - this is best-effort persistence
        console.warn('Failed to save chat history:', e);
    }
}

function refreshVerifiedModelsDatalist() {
    const dl = document.getElementById('verified-models');
    if (!dl) return;
    dl.innerHTML = '';
    const provider = document.getElementById('provider-select').value;
    const filtered = verifiedModels.filter(v => v.provider === provider);
    for (const item of filtered) {
        const opt = document.createElement('option');
        opt.value = item.model;
        dl.appendChild(opt);
    }

    // Also populate quick-pick select
    const sel = document.getElementById('verified-model-select');
    if (sel) {
        sel.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = filtered.length ? 'Select verified model…' : '(none yet)';
        sel.appendChild(placeholder);
        for (const item of filtered) {
            const o = document.createElement('option');
            o.value = item.model;
            o.textContent = item.model;
            sel.appendChild(o);
        }
    }
}

function updateModelPlaceholder() {
    const providerSelect = document.getElementById('provider-select');
    const modelInput = document.getElementById('model-input');
    const selectedOption = providerSelect.options[providerSelect.selectedIndex];
    
    if (selectedOption && selectedOption.value) {
        selectedProvider = selectedOption.value;
        modelInput.placeholder = selectedOption.dataset.placeholder || 'Enter model name...';
        modelInput.disabled = false;
        refreshVerifiedModelsDatalist();
    } else {
        selectedProvider = "";
        modelInput.placeholder = 'Select a provider first...';
        modelInput.disabled = true;
    }
}

async function testModel() {
    const provider = document.getElementById('provider-select').value;
    const model = document.getElementById('model-input').value.trim();
    const testButton = document.getElementById('test-button');
    const testButtonText = document.getElementById('test-button-text');
    const testStatus = document.getElementById('test-status');
    
    if (!provider) {
        testStatus.textContent = 'Please select a provider';
        testStatus.style.color = '#e74c3c';
        return;
    }
    
    if (!model) {
        testStatus.textContent = 'Please enter a model name';
        testStatus.style.color = '#e74c3c';
        return;
    }
    
    // Update button to show loading state
    testButton.disabled = true;
    testButton.style.background = '#95a5a6';
    testButton.style.cursor = 'not-allowed';
    testButtonText.textContent = 'Testing...';
    testStatus.textContent = 'Testing model connection...';
    testStatus.style.color = '#666';
    
    try {
        const response = await fetch('/api/chat/test-model', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                provider: provider,
                model: model
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            testStatus.textContent = '✓ ' + data.message;
            testStatus.style.color = '#27ae60';
            // Refresh verified models and persist last-used
            await loadChatSettings();
        } else {
            testStatus.textContent = '✗ ' + data.message;
            testStatus.style.color = '#e74c3c';
            await loadChatSettings();
        }
    } catch (error) {
        testStatus.textContent = '✗ Error: ' + error.message;
        testStatus.style.color = '#e74c3c';
    } finally {
        // Restore button state
        testButton.disabled = false;
        testButton.style.background = '#27ae60';
        testButton.style.cursor = 'pointer';
        testButtonText.textContent = 'Test Model';
    }
}

function addMessage(role, content, debugInfo = null, sources = null) {
    const messagesDiv = document.getElementById('chat-messages');
    
    // Remove empty state if present
    const emptyState = messagesDiv.querySelector('.empty-state');
    if (emptyState) {
        emptyState.remove();
    }
    
    const messageDiv = document.createElement('div');
    messageDiv.style.marginBottom = '20px';
    messageDiv.style.display = 'flex';
    messageDiv.style.flexDirection = 'column';
    messageDiv.style.alignItems = role === 'user' ? 'flex-end' : 'flex-start';
    
    const messageBubble = document.createElement('div');
    messageBubble.style.maxWidth = '70%';
    messageBubble.style.padding = '12px 16px';
    messageBubble.style.borderRadius = '12px';
    messageBubble.style.backgroundColor = role === 'user' ? '#3498db' : '#ecf0f1';
    messageBubble.style.color = role === 'user' ? 'white' : '#2c3e50';
    messageBubble.style.wordWrap = 'break-word';
    messageBubble.style.whiteSpace = 'pre-wrap';
    messageBubble.style.fontSize = '14px';
    messageBubble.style.lineHeight = '1.5';
    
    messageBubble.textContent = content;
    messageDiv.appendChild(messageBubble);
    
    // Add sources section (always visible when sources exist)
    if (role === 'assistant' && sources && Array.isArray(sources) && sources.length > 0) {
        const sourcesDiv = document.createElement('div');
        sourcesDiv.style.marginTop = '8px';
        sourcesDiv.style.padding = '8px 12px';
        sourcesDiv.style.backgroundColor = '#e8f4f8';
        sourcesDiv.style.borderRadius = '6px';
        sourcesDiv.style.fontSize = '12px';
        sourcesDiv.style.color = '#2c3e50';
        sourcesDiv.style.maxWidth = '70%';
        sourcesDiv.style.borderLeft = '3px solid #3498db';
        
        let sourcesHtml = '<strong style="color: #2980b9;">Sources:</strong><br>';
        sources.forEach((src, idx) => {
            const title = src.title || 'Untitled';
            const convId = src.conversation_id;
            
            if (convId) {
                const msgIds = src.message_ids;
                const msgId = Array.isArray(msgIds) && msgIds.length > 0 ? msgIds[0] : null;
                let url = `/main?conversation=${encodeURIComponent(convId)}`;
                if (msgId) {
                    url += `&message=${encodeURIComponent(msgId)}`;
                }
                sourcesHtml += `${idx + 1}. <a href="${url}" style="color: #0066cc; text-decoration: underline; cursor: pointer;" onclick="event.preventDefault(); window.location.href='${url}';">${escapeHtml(title)}</a><br>`;
            } else {
                sourcesHtml += `${idx + 1}. ${escapeHtml(title)}<br>`;
            }
        });
        
        sourcesDiv.innerHTML = sourcesHtml;
        messageDiv.appendChild(sourcesDiv);
    }
    
    // Add debug info if enabled
    if (debugInfo && document.getElementById('show-debug').checked) {
        const debugDiv = document.createElement('div');
        debugDiv.style.marginTop = '8px';
        debugDiv.style.padding = '8px';
        debugDiv.style.backgroundColor = '#fff3cd';
        debugDiv.style.borderRadius = '4px';
        debugDiv.style.fontSize = '11px';
        debugDiv.style.color = '#856404';
        debugDiv.style.maxWidth = '70%';
        
        // Build sources list with clickable links
        let sourcesHtml = '';
        if (debugInfo.sources_preview && Array.isArray(debugInfo.sources_preview) && debugInfo.sources_preview.length > 0) {
            sourcesHtml = '<br><strong>Sources:</strong><br>';
            debugInfo.sources_preview.forEach((src, idx) => {
                const title = src.title || 'Untitled';
                const chunkIdx = src.chunk_index !== undefined ? src.chunk_index : '?';
                const sim = src.similarity !== undefined ? src.similarity.toFixed(2) : '?';
                const convId = src.conversation_id;
                const msgIds = src.message_ids;
                
                if (convId) {
                    // Make it a clickable link
                    const msgId = Array.isArray(msgIds) && msgIds.length > 0 ? msgIds[0] : null;
                    let url = `/main?conversation=${encodeURIComponent(convId)}`;
                    if (msgId) {
                        url += `&message=${encodeURIComponent(msgId)}`;
                    }
                    sourcesHtml += `${idx + 1}. <a href="${url}" style="color: #0066cc; text-decoration: underline; cursor: pointer;" onclick="event.preventDefault(); window.location.href='${url}';">${escapeHtml(title)}</a> (Chunk ${chunkIdx}, sim: ${sim})<br>`;
                } else {
                    // Fallback: just text
                    sourcesHtml += `${idx + 1}. ${escapeHtml(title)} (Chunk ${chunkIdx}, sim: ${sim})<br>`;
                }
            });
        }
        
        debugDiv.innerHTML = `
            <strong>Debug:</strong><br>
            Improved query: ${escapeHtml(debugInfo.improved_query || 'N/A')}<br>
            Context chunks: ${debugInfo.context_chunks_used || 0}<br>
            Similarity scores: ${(debugInfo.similarity_scores || []).map(s => s.toFixed(2)).join(', ') || 'N/A'}
            ${sourcesHtml}
            ${debugInfo.context_preview ? `<br><br><strong>Context preview sent to LLM:</strong><br><pre style="white-space:pre-wrap; margin:6px 0 0 0;">${escapeHtml(debugInfo.context_preview)}</pre>` : ''}
        `;
        messageDiv.appendChild(debugDiv);
    }
    
    messagesDiv.appendChild(messageDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function escapeHtml(str) {
    return (str || '').replace(/[&<>"']/g, function(m) {
        return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]);
    });
}

async function sendMessage() {
    const input = document.getElementById('chat-input');
    const query = input.value.trim();
    
    if (!query) {
        return;
    }
    
    const provider = document.getElementById('provider-select').value;
    const model = document.getElementById('model-input').value.trim();
    
    if (!provider) {
        alert('Please select a provider first');
        return;
    }
    
    if (!model) {
        alert('Please enter a model name');
        return;
    }
    
    // Format model name for API
    selectedProvider = provider;
    selectedModel = model;
    
    // Disable input
    input.disabled = true;
    const sendButton = document.getElementById('send-button');
    sendButton.disabled = true;
    sendButton.textContent = 'Sending...';
    sendButton.style.background = '#95a5a6';
    const statusDiv = document.getElementById('chat-status');
    statusDiv.textContent = 'Processing...';
    statusDiv.style.color = '#666';
    
    // Add user message
    addMessage('user', query);
    chatHistory.push({role: 'user', content: query});
    // Save history after adding user message
    saveChatHistory();
    
    // Clear input
    input.value = '';
    
    try {
        const ctxInput = document.getElementById('context-window-input');
        const contextWindowSize = Math.max(1000, Math.min(100000, parseInt(ctxInput && ctxInput.value ? ctxInput.value : '4000', 10) || 4000));
        const minSimilarity = parseFloat(document.getElementById('min-similarity-slider').value);
        const maxChunks = parseInt(document.getElementById('max-chunks').value);
        
        // Format model name based on provider
        let formattedModel = selectedModel;
        if (selectedProvider === 'lmstudio') {
            formattedModel = `openai/${selectedModel}`;
        } else if (selectedProvider === 'ollama') {
            formattedModel = `ollama/${selectedModel}`;
        } else if (selectedProvider !== 'custom') {
            formattedModel = `${selectedProvider}/${selectedModel}`;
        }
        
        // Create assistant message bubble for streaming updates
        addMessage('assistant', '');
        const messagesDiv = document.getElementById('chat-messages');
        const lastMessageBubble = messagesDiv.lastChild.querySelector('div');

        const response = await fetch('/api/chat/completion-stream', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                query: query,
                model: formattedModel,
                provider: selectedProvider,
                model_name: selectedModel,
                history: chatHistory,
                context_window_size: contextWindowSize,
                min_similarity: minSimilarity,
                max_context_chunks: maxChunks,
                include_debug: document.getElementById('show-debug').checked
            })
        });

        if (!response.ok || !response.body) {
            // fallback to non-streaming endpoint
            const r2 = await fetch('/api/chat/completion', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    query: query,
                    model: formattedModel,
                    provider: selectedProvider,
                    model_name: selectedModel,
                    history: chatHistory,
                    context_window_size: contextWindowSize,
                    min_similarity: minSimilarity,
                    max_context_chunks: maxChunks,
                    include_debug: document.getElementById('show-debug').checked
                })
            });
            const data = await r2.json();
            lastMessageBubble.textContent = data.response || '(no response)';
            chatHistory.push({role: 'assistant', content: data.response});
            // Save history after receiving response
            saveChatHistory();
            // Add sources if available (non-streaming path)
            if (data.sources && Array.isArray(data.sources) && data.sources.length > 0) {
                const messagesDiv = document.getElementById('chat-messages');
                const lastMsgDiv = messagesDiv.lastChild;
                if (lastMsgDiv) {
                    const sourcesDiv = document.createElement('div');
                    sourcesDiv.style.marginTop = '8px';
                    sourcesDiv.style.padding = '8px 12px';
                    sourcesDiv.style.backgroundColor = '#e8f4f8';
                    sourcesDiv.style.borderRadius = '6px';
                    sourcesDiv.style.fontSize = '12px';
                    sourcesDiv.style.color = '#2c3e50';
                    sourcesDiv.style.maxWidth = '70%';
                    sourcesDiv.style.borderLeft = '3px solid #3498db';
                    
                    let sourcesHtml = '<strong style="color: #2980b9;">Sources:</strong><br>';
                    data.sources.forEach((src, idx) => {
                        const title = src.title || 'Untitled';
                        const convId = src.conversation_id;
                        if (convId) {
                            const msgIds = src.message_ids;
                            const msgId = Array.isArray(msgIds) && msgIds.length > 0 ? msgIds[0] : null;
                            let url = `/main?conversation=${encodeURIComponent(convId)}`;
                            if (msgId) {
                                url += `&message=${encodeURIComponent(msgId)}`;
                            }
                            sourcesHtml += `${idx + 1}. <a href="${url}" style="color: #0066cc; text-decoration: underline; cursor: pointer;" onclick="event.preventDefault(); window.location.href='${url}';">${escapeHtml(title)}</a><br>`;
                        } else {
                            sourcesHtml += `${idx + 1}. ${escapeHtml(title)}<br>`;
                        }
                    });
                    sourcesDiv.innerHTML = sourcesHtml;
                    lastMsgDiv.appendChild(sourcesDiv);
                }
            }
            statusDiv.textContent = '';
            return;
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let fullText = '';
        let lastMeta = null;

        function scrollToBottom() {
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        while (true) {
            const {value, done} = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, {stream: true});

            // parse SSE frames separated by blank line
            const parts = buffer.split('\n\n');
            buffer = parts.pop() || '';
            for (const frame of parts) {
                const line = frame.split('\n').find(l => l.startsWith('data: '));
                if (!line) continue;
                let payload;
                try {
                    payload = JSON.parse(line.slice(6));
                } catch (e) {
                    continue;
                }
                if (payload.type === 'meta') {
                    lastMeta = payload;
                } else if (payload.type === 'delta') {
                    fullText += payload.content || '';
                    lastMessageBubble.textContent = fullText;
                    scrollToBottom();
                } else if (payload.type === 'done') {
                    if (payload.response != null && payload.response.length) {
                        fullText = payload.response;
                        lastMessageBubble.textContent = fullText;
                    }
                    scrollToBottom();
                } else if (payload.type === 'error') {
                    throw new Error(payload.error || 'stream error');
                }
            }
        }

        // Attach debug info to the *last* assistant message by re-adding with debug (simple approach)
        if (lastMeta && document.getElementById('show-debug').checked) {
            // remove last (empty) assistant message wrapper and re-add with debug
            messagesDiv.removeChild(messagesDiv.lastChild);
            // Ensure sources_preview is available from meta
            if (!lastMeta.sources_preview && lastMeta.context_chunks_used > 0) {
                // Fallback: construct from what we have (though this shouldn't happen if backend is correct)
                lastMeta.sources_preview = [];
            }
            // Use sources from meta if available, otherwise construct from sources_preview
            const sources = lastMeta.sources || (lastMeta.sources_preview || []);
            addMessage('assistant', fullText, lastMeta, sources);
        } else if (lastMeta && lastMeta.sources) {
            // Even without debug, show sources if available
            messagesDiv.removeChild(messagesDiv.lastChild);
            addMessage('assistant', fullText, null, lastMeta.sources);
        }
        chatHistory.push({role: 'assistant', content: fullText});
        // Save history after receiving streaming response
        saveChatHistory();
        
        statusDiv.textContent = '';
    } catch (error) {
        console.error('Error:', error);
        statusDiv.textContent = `Error: ${error.message}`;
        statusDiv.style.color = '#e74c3c';
        
        addMessage('assistant', `Error: ${error.message}`);
    } finally {
        input.disabled = false;
        sendButton.disabled = false;
        sendButton.textContent = 'Send';
        sendButton.style.background = '#3498db';
        input.focus();
    }
}

async function clearHistory() {
    if (confirm('Clear conversation history. Are you sure?')) {
        chatHistory = [];
        document.getElementById('chat-messages').innerHTML = `
            <div class="empty-state" style="text-align: center; padding: 60px 20px; color: #999;">
                <p style="font-size: 16px; margin: 0;">Start a conversation by typing a message below.</p>
            </div>
        `;
        // Clear from database too
        try {
            await fetch('/api/chat/clear-history', {method: 'POST'});
        } catch (e) {
            console.warn('Failed to clear chat history from database:', e);
        }
    }
}

function toggleDebug() {
    // Debug info is shown/hidden per message, so we just need to refresh display
    // This is handled in addMessage function
}

// Save history before page unload (e.g., when clicking source links)
window.addEventListener('beforeunload', function() {
    // Use sendBeacon for reliable delivery even during navigation
    if (chatHistory.length > 0) {
        try {
            const data = JSON.stringify({history: chatHistory});
            const blob = new Blob([data], {type: 'application/json'});
            navigator.sendBeacon('/api/chat/save-history', blob);
        } catch (e) {
            // Fallback: try synchronous fetch (less reliable but better than nothing)
            console.warn('sendBeacon failed, trying sync save:', e);
        }
    }
});

// Also save periodically (every 30 seconds) as a safety net
setInterval(function() {
    if (chatHistory.length > 0) {
        saveChatHistory();
    }
}, 30000);

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    loadProviders().then(loadChatSettings);
});
</script>
{% endblock %}
